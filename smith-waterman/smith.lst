     1                                  ; Proyecto #2 de arquitectura de computadores
     2                                  ;
     3                                  ;	
     4                                  ;
     5                                  ; ---------------------------------------------------------------------------------------------------------------------------
     6                                  ;  Este proyecto genera una cadena de ADN definida por el usuario y esta es salvada
     7                                  ;  en un archivo tipo .adn
     8                                  ; ---------------------------------------------------------------------------------------------------------------------------
     9                                  
    10                                  ; La siguiente parte de código son tags para hacer más legible el código
    11                                  	sys_exit 	equ 	1
    12                                  	sys_read 	equ 	3
    13                                  	sys_write 	equ 	4
    14                                  	sys_open 	equ 	5	
    15                                  	sys_close 	equ 	6
    16                                  	sys_create 	equ 	8
    17                                  	stdin 		equ		0
    18                                  	stdout 		equ 	1
    19                                  
    20                                  ; La siguiente parte de código son datos no inicializados
    21                                  section .bss
    22 00000000 <res 00000064>          	buffer resb 100	
    23                                  	
    24                                  	LenMatriz equ 1000000
    25 00000064 <res 000F4240>          	matriz resb LenMatriz
    26                                  	
    27                                  	lenInput1 equ 35
    28 000F42A4 <res 00000023>          	input1 resb lenInput1
    29                                  	
    30                                  	lenInput2 equ 35
    31 000F42C7 <res 00000023>          	input2 resb lenInput2
    32                                  	
    33                                  	LenArchivo_1 equ 1000000
    34 000F42EA <res 000F4240>          	archivo_1 resb LenArchivo_1
    35                                  	
    36                                  	LenArchivo_2 equ 1000000
    37 001E852A <res 000F4240>          	archivo_2 resb LenArchivo_2
    38                                  	
    39                                  	LenActual_1 equ 1
    40 002DC76A <res 00000001>          	actual_1 resb LenActual_1
    41                                  	
    42                                  	LenActual_2 equ 1
    43 002DC76B <res 00000001>          	actual_2 resb LenActual_2
    44                                  	
    45                                  	LenArgumento1 equ 20
    46 002DC76C <res 00000014>          	argumento1 resb LenArgumento1
    47                                  	
    48                                  	LenArgumento2 equ 20
    49 002DC780 <res 00000014>          	argumento2 resb LenArgumento2
    50                                  	
    51                                  	LenArgumento3 equ 20
    52 002DC794 <res 00000014>          	argumento3 resb LenArgumento3
    53                                  
    54                                  	
    55                                  
    56                                  ; La siguiente parte de código son datos inicializados
    57                                  section .data
    58                                  
    59 00000000 207C20                  espacio: db " | "
    60 00000003 0A                      enter: db 10
    61                                  
    62 00000004 496E74726F64757A63-     mnsj1: db "Introduzca el nombre del primer documento (incluyendo la extension):",10
    63 0000000D 6120656C206E6F6D62-
    64 00000016 72652064656C207072-
    65 0000001F 696D657220646F6375-
    66 00000028 6D656E746F2028696E-
    67 00000031 636C7579656E646F20-
    68 0000003A 6C6120657874656E73-
    69 00000043 696F6E293A0A       
    70                                  lenmnsj1: equ $-mnsj1
    71                                  
    72 00000049 496E74726F64757A63-     mnsj2: db "Introduzca el nombre del segundo documento (incluyendo la extension):",10
    73 00000052 6120656C206E6F6D62-
    74 0000005B 72652064656C207365-
    75 00000064 67756E646F20646F63-
    76 0000006D 756D656E746F202869-
    77 00000076 6E636C7579656E646F-
    78 0000007F 206C6120657874656E-
    79 00000088 73696F6E293A0A     
    80                                  lenmnsj2: equ $-mnsj2
    81                                  
    82 0000008F 4572726F7220616C20-     errorMensj: db "Error al abrir el archivo",10,10
    83 00000098 616272697220656C20-
    84 000000A1 6172636869766F0A0A 
    85                                  lenErrorMensj: equ $-errorMensj
    86                                  
    87                                  ; La siguiente parte de código son las instrucciones
    88                                  section .text
    89                                  ; inicio del codigo del programa
    90                                  	global _start 
    91                                  	
    92                                  _start:
    93 00000000 90                      	nop		
    94                                  	
    95                                  Preguntar_Nombre_1:
    96 00000001 B9[04000000]            	mov ecx, mnsj1
    97 00000006 BA45000000              	mov edx, lenmnsj1
    98 0000000B E8A3020000              	call DisplayText
    99                                  	
   100 00000010 B9[A4420F00]            	mov ecx, input1
   101 00000015 BA23000000              	mov edx, lenInput1
   102 0000001A E8A1020000              	call ReadText
   103 0000001F 48                      	dec eax
   104 00000020 C680[A4420F00]00        	mov byte[input1+eax],0h
   105                                  
   106                                  .Abrir_archivo_1:	
   107 00000027 B805000000              	mov eax, sys_open
   108 0000002C BB[A4420F00]            	mov ebx, input1
   109 00000031 B902000000              	mov ecx, 2
   110 00000036 CD80                    	int 80h
   111 00000038 50                      	push eax
   112 00000039 85C0                    	test eax, eax 					; primero nos aseguramos que abrio bien
   113 0000003B 0F884D020000            	js	error						; no es asi? imprime mensaje de error
   114 00000041 89C3                    	mov	ebx, eax					; paso al ebx el FD
   115 00000043 B9[EA420F00]            	mov	ecx, archivo_1				; paso el puntero del buffer con el archivo
   116 00000048 BA40420F00              	mov	edx, LenArchivo_1			; y su len correspondiente
   117 0000004D B803000000              	mov	eax, sys_read				; y llamo a read de dicho archivo
   118 00000052 CD80                    	int 80h		
   119 00000054 5B                      	pop ebx
   120 00000055 50                      	push eax						;salvo la cantidad de digitos
   121 00000056 B806000000              	mov eax, sys_close
   122 0000005B CD80                    	int 80h
   123                                  	
   124                                  Preguntar_Nombre_2:	
   125 0000005D B9[49000000]            	mov ecx, mnsj2
   126 00000062 BA46000000              	mov edx, lenmnsj2
   127 00000067 E847020000              	call DisplayText
   128                                  	
   129 0000006C B9[C7420F00]            	mov ecx, input2
   130 00000071 BA23000000              	mov edx, lenInput2
   131 00000076 E845020000              	call ReadText
   132 0000007B 48                      	dec eax
   133 0000007C C680[C7420F00]00        	mov byte[input2+eax],0h
   134                                  
   135                                  .Abrir_archivo_2:
   136 00000083 B805000000              	mov eax, sys_open
   137 00000088 BB[C7420F00]            	mov ebx, input2
   138 0000008D B902000000              	mov ecx, 2
   139 00000092 CD80                    	int 80h
   140 00000094 50                      	push eax
   141 00000095 85C0                    	test eax, eax 					; primero nos aseguramos que abrio bien
   142 00000097 0F88F1010000            	js	error						; no es asi? imprime mensaje de error
   143 0000009D 89C3                    	mov	ebx, eax					; paso al ebx el FD
   144 0000009F B9[2A851E00]            	mov	ecx, archivo_2				; paso el puntero del buffer con el archivo
   145 000000A4 BA40420F00              	mov	edx, LenArchivo_2			; y su len correspondiente
   146 000000A9 B803000000              	mov	eax, sys_read				; y llamo a read de dicho archivo
   147 000000AE CD80                    	int 80h		
   148 000000B0 5B                      	pop ebx
   149 000000B1 50                      	push eax						;salvo la cantidad de digitos
   150 000000B2 B806000000              	mov eax, sys_close
   151 000000B7 CD80                    	int 80h
   152                                  		
   153                                  llenar_ceros_fila:
   154 000000B9 58                      	pop eax
   155 000000BA 5A                      	pop edx
   156 000000BB 52                      	push edx
   157 000000BC 50                      	push eax
   158 000000BD B900000000              	mov ecx, 0
   159                                  .ciclo:
   160 000000C2 C681[64000000]00        	mov byte[matriz+ecx], 0
   161 000000C9 41                      	inc ecx
   162 000000CA 39D1                    	cmp ecx, edx
   163 000000CC 75F4                    	jne .ciclo
   164 000000CE 5B                      	pop ebx
   165 000000CF 58                      	pop eax
   166 000000D0 50                      	push eax
   167 000000D1 53                      	push ebx
   168 000000D2 31D2                    	xor edx, edx
   169 000000D4 F7E3                    	mul ebx
   170 000000D6 89C2                    	mov edx, eax
   171                                  	
   172                                  llenar_basura:
   173 000000D8 C681[64000000]31        	mov byte[matriz+ecx], "1"
   174 000000DF 41                      	inc ecx
   175 000000E0 39D1                    	cmp ecx, edx
   176 000000E2 75F4                    	jne llenar_basura
   177 000000E4 58                      	pop eax
   178 000000E5 59                      	pop ecx
   179 000000E6 51                      	push ecx
   180 000000E7 50                      	push eax
   181 000000E8 89C8                    	mov eax, ecx
   182                                  
   183                                  llenar_ceros_col:
   184 000000EA C681[64000000]00        	mov byte[matriz+ecx], 0
   185 000000F1 01C1                    	add ecx, eax
   186 000000F3 39D1                    	cmp ecx, edx
   187 000000F5 75F3                    	jne llenar_ceros_col
   188                                  	
   189 000000F7 58                      	pop eax
   190 000000F8 59                      	pop ecx
   191 000000F9 51                      	push ecx
   192 000000FA 50                      	push eax
   193 000000FB 41                      	inc ecx
   194                                  	
   195                                  Ciclo_Principal:
   196                                  .ArribaIzq:
   197 000000FC 89C8                    	mov eax, ecx
   198 000000FE 48                      	dec eax
   199 000000FF 5A                      	pop edx
   200 00000100 5B                      	pop ebx
   201 00000101 53                      	push ebx
   202 00000102 52                      	push edx
   203 00000103 31D2                    	xor edx, edx
   204 00000105 F7F3                    	div ebx
   205 00000107 48                      	dec eax
   206 00000108 60                      	pusha
   207 00000109 31D2                    	xor edx, edx
   208 0000010B 8A98[EA420F00]          	mov bl, byte[archivo_1+eax]
   209 00000111 889A[6AC72D00]          	mov byte[actual_1+edx], bl
   210 00000117 61                      	popa
   211 00000118 89C2                    	mov edx, eax
   212 0000011A 40                      	inc eax
   213 0000011B F7E3                    	mul ebx
   214 0000011D 89C3                    	mov ebx, eax
   215 0000011F 89C8                    	mov eax, ecx
   216 00000121 29D8                    	sub eax, ebx
   217 00000123 48                      	dec eax
   218 00000124 60                      	pusha
   219 00000125 31D2                    	xor edx, edx
   220 00000127 8A98[2A851E00]          	mov bl, byte[archivo_2+eax]
   221 0000012D 889A[6BC72D00]          	mov byte[actual_2+edx], bl
   222 00000133 61                      	popa
   223 00000134 31D2                    	xor edx, edx
   224 00000136 8A9A[6AC72D00]          	mov bl, byte[actual_1+edx]
   225 0000013C 8ABA[6BC72D00]          	mov bh, byte[actual_2+edx]
   226 00000142 E858010000              	call match
   227 00000147 8982[6CC72D00]          	mov [argumento1+edx], eax
   228 0000014D 5A                      	pop edx
   229 0000014E 5B                      	pop ebx
   230 0000014F 53                      	push ebx
   231 00000150 52                      	push edx
   232 00000151 31D2                    	xor edx, edx
   233 00000153 43                      	inc ebx
   234 00000154 89C8                    	mov eax, ecx
   235 00000156 29D8                    	sub eax, ebx
   236 00000158 8A98[64000000]          	mov bl, byte[matriz+eax]
   237 0000015E 89D8                    	mov eax, ebx
   238 00000160 0382[6CC72D00]          	add eax, [argumento1+edx]
   239 00000166 8982[6CC72D00]          	mov [argumento1+edx], eax
   240                                  
   241                                  .Izquierda:
   242 0000016C 89C8                    	mov eax, ecx
   243 0000016E 48                      	dec eax
   244 0000016F 8A98[64000000]          	mov bl, byte[matriz+eax]
   245 00000175 89D8                    	mov eax, ebx
   246 00000177 48                      	dec eax								;gab
   247 00000178 8982[80C72D00]          	mov [argumento2+edx], eax
   248                                  
   249                                  .Arriba:
   250 0000017E 31D2                    	xor edx, edx
   251 00000180 89C8                    	mov eax, ecx
   252 00000182 5A                      	pop edx
   253 00000183 5B                      	pop ebx
   254 00000184 53                      	push ebx
   255 00000185 52                      	push edx
   256 00000186 29D8                    	sub eax, ebx
   257 00000188 8A98[64000000]          	mov bl, byte[matriz+eax]
   258 0000018E 89D8                    	mov eax, ebx
   259 00000190 48                      	dec eax								;gab
   260 00000191 8982[94C72D00]          	mov [argumento3+edx], eax
   261 00000197 89C2                    	mov edx, eax
   262                                  
   263                                  .InsertarNuevoValor:
   264 00000199 51                      	push ecx
   265 0000019A B800000000              	mov eax, 0
   266 0000019F 8B98[6CC72D00]          	mov ebx, [argumento1+eax]
   267 000001A5 8B88[80C72D00]          	mov ecx, [argumento2+eax]
   268 000001AB E89D000000              	call maxNumber
   269 000001B0 59                      	pop ecx
   270 000001B1 8881[64000000]          	mov byte[matriz+ecx],al
   271                                  	
   272                                  	
   273                                  .verificar_fin:
   274 000001B7 58                      	pop eax
   275 000001B8 5B                      	pop ebx
   276 000001B9 53                      	push ebx
   277 000001BA 50                      	push eax
   278 000001BB F7E3                    	mul ebx
   279 000001BD 48                      	dec eax
   280 000001BE 39C8                    	cmp eax, ecx
   281 000001C0 741D                    	je imprime_res
   282                                  
   283                                  .verificar_fin_linea:
   284 000001C2 89C8                    	mov eax, ecx
   285 000001C4 40                      	inc eax
   286 000001C5 5A                      	pop edx
   287 000001C6 5B                      	pop ebx
   288 000001C7 53                      	push ebx
   289 000001C8 52                      	push edx
   290 000001C9 31D2                    	xor edx, edx
   291 000001CB F7F3                    	div ebx
   292 000001CD 83FA00                  	cmp edx, 0
   293 000001D0 7507                    	jne .NoEsFin
   294 000001D2 41                      	inc ecx
   295 000001D3 41                      	inc ecx
   296 000001D4 E923FFFFFF              	jmp Ciclo_Principal
   297                                  .NoEsFin:
   298 000001D9 41                      	inc ecx
   299 000001DA E91DFFFFFF              	jmp Ciclo_Principal
   300                                  	
   301                                  imprime_res:
   302 000001DF 58                      	pop eax
   303 000001E0 5B                      	pop ebx
   304 000001E1 89D9                    	mov ecx, ebx
   305 000001E3 F7E3                    	mul ebx
   306 000001E5 48                      	dec eax
   307 000001E6 89CB                    	mov ebx, ecx
   308 000001E8 4B                      	dec ebx
   309 000001E9 31C9                    	xor ecx, ecx
   310 000001EB 31D2                    	xor edx, edx
   311                                  
   312                                  .ciclo:
   313 000001ED 60                      	pusha
   314 000001EE 8A91[64000000]          	mov dl, byte[matriz+ecx]
   315 000001F4 89D0                    	mov eax, edx
   316 000001F6 8D35[00000000]          	lea esi,[buffer]
   317 000001FC E8CC000000              	call int_to_string
   318 00000201 89C1                    	mov ecx, eax
   319 00000203 BA07000000              	mov edx, 7
   320 00000208 E8A6000000              	call DisplayText
   321 0000020D 61                      	popa
   322 0000020E 60                      	pusha
   323 0000020F 31D2                    	xor edx, edx
   324 00000211 89C8                    	mov eax, ecx
   325 00000213 40                      	inc eax
   326 00000214 43                      	inc ebx
   327 00000215 F7F3                    	div ebx
   328 00000217 83FA00                  	cmp edx, 0
   329 0000021A 7514                    	jne .printLinea
   330 0000021C 61                      	popa
   331 0000021D 60                      	pusha
   332 0000021E B9[03000000]            	mov ecx, enter
   333 00000223 BA01000000              	mov edx, 1
   334 00000228 E886000000              	call DisplayText
   335 0000022D 61                      	popa
   336 0000022E EB12                    	jmp .verFin
   337                                  	
   338                                  .printLinea:
   339 00000230 61                      	popa
   340 00000231 60                      	pusha
   341 00000232 B9[00000000]            	mov ecx, espacio
   342 00000237 BA03000000              	mov edx, 3
   343 0000023C E872000000              	call DisplayText
   344 00000241 61                      	popa
   345                                  
   346                                  .verFin:
   347 00000242 39C8                    	cmp eax, ecx
   348 00000244 0F84B3000000            	je Cerrar
   349 0000024A 41                      	inc ecx
   350 0000024B EBA0                    	jmp .ciclo
   351                                  	
   352                                  ;Funcion que permite saber el numero mayor entre 4 numeros
   353                                  ;ocupa las 4 numeros en los 4 registros principales
   354                                  ;				eax-ebx-ecx-edx
   355                                  maxNumber:
   356 0000024D 39D8                    	cmp eax, ebx			;compara el eax con ebx
   357 0000024F 7C02                    	jl .ebx_mayor_eax		;ebx es mayor
   358 00000251 7F06                    	jg .eax_mayor_ebx		;eax es mayor
   359                                  	
   360                                  .ebx_mayor_eax:				;comparo ebx con ecx
   361 00000253 39CB                    	cmp ebx, ecx			;ecx es mayor
   362 00000255 7C1A                    	jl .ecx_mayor_ebx		;ebx es mayor
   363 00000257 7F0C                    	jg .ebx_mayor_ecx
   364                                  	
   365                                  .eax_mayor_ebx:				;comparo eax con ecx
   366 00000259 39C8                    	cmp eax, ecx			;ecx mayor eax
   367 0000025B 7C0E                    	jl .ecx_mayor_eax		;eax mayor a ecx
   368 0000025D 7F00                    	jg .eax_mayor_ecx
   369                                  	
   370                                  .eax_mayor_ecx:				
   371 0000025F 39D0                    	cmp eax, edx			;comparo eax con edx
   372 00000261 7C14                    	jl .edx_mayor_eax		;edx es mayor
   373 00000263 7F16                    	jg .eax_mayor_edx		;eax es mayor
   374                                  
   375                                  .ebx_mayor_ecx:
   376 00000265 39D3                    	cmp ebx, edx			;comparo ebx con edx
   377 00000267 7C14                    	jl .edx_mayor_ebx		;edx es mayor
   378 00000269 7F16                    	jg .ebx_mayor_edx		;ebx es mayor
   379                                  	
   380                                  .ecx_mayor_eax:
   381 0000026B 39D1                    	cmp ecx, edx			;comparo ecx con edx
   382 0000026D 7C16                    	jl .edx_mayor_ecx		;edx es mayor
   383 0000026F 7F18                    	jg .ecx_mayor_edx		;exc es mayor
   384                                  	
   385                                  .ecx_mayor_ebx:
   386 00000271 39D1                    	cmp ecx, edx			;comparo el ecx con el edx
   387 00000273 7C10                    	jl .edx_mayor_ecx		;edx es mayor
   388 00000275 7F12                    	jg .ecx_mayor_edx		;ecx es mayor
   389                                  
   390                                  ;en todas estas etiquetas paso el valor mayor al eax y paso a finalizar el procedimiento
   391                                  .edx_mayor_eax:
   392 00000277 89D0                    	mov eax, edx
   393 00000279 EB12                    	jmp .mayor
   394                                  .eax_mayor_edx:
   395 0000027B EB10                    	jmp .mayor
   396                                  .edx_mayor_ebx:
   397 0000027D 89D0                    	mov eax, edx
   398 0000027F EB0C                    	jmp .mayor
   399                                  .ebx_mayor_edx:
   400 00000281 89D8                    	mov eax, ebx
   401 00000283 EB08                    	jmp .mayor
   402                                  .edx_mayor_ecx:
   403 00000285 89D0                    	mov eax, edx
   404 00000287 EB04                    	jmp .mayor
   405                                  .ecx_mayor_edx:
   406 00000289 89C8                    	mov eax, ecx
   407 0000028B EB00                    	jmp .mayor
   408                                  ;salgo del procedimiento
   409                                  .mayor:
   410                                  
   411                                  		;pusha
   412                                  	;lea esi,[buffer]
   413                                  	;call int_to_string
   414                                  	;mov ecx, eax
   415                                  	;mov edx, 7
   416                                  	;call DisplayText
   417                                  	;mov ecx, enter
   418                                  	;mov edx, 1
   419                                  	;call DisplayText
   420                                  	;popa
   421                                  	
   422 0000028D C3                      	ret
   423                                  
   424                                  
   425                                  ;muestra en pantalla que ocurrio un error al abrir el archivo
   426                                  error:
   427 0000028E B9[8F000000]            	mov ecx, errorMensj
   428 00000293 BA1B000000              	mov edx, lenErrorMensj
   429 00000298 E816000000              	call DisplayText
   430 0000029D EB5E                    	jmp Cerrar
   431                                  ;esta funcion recibe en el bl y cl 2 argumentos y devuelve en el eax 1 si hay match y -1 si no hay match
   432                                  match:
   433 0000029F 38FB                    	cmp bl, bh			;comparo el bl con el cl
   434 000002A1 7402                    	je .si				;si es igual voy a si
   435 000002A3 7507                    	jne .no				;si no es igual voy a no
   436                                  	
   437                                  .si:				
   438 000002A5 B801000000              	mov eax, 1			;muevo al eax un 1
   439 000002AA EB06                    	jmp .sale			;brinco a salir
   440                                  .no:
   441 000002AC B800000000              	mov eax, 0			;muevo al eax un cero
   442 000002B1 48                      	dec eax				;decremento el eax
   443                                  .sale:
   444 000002B2 C3                      	ret					;retorno
   445                                  ; La siguiente subrutina llama el kernel y muetra un mensaje en pantalla.
   446                                  ; desplega algo en la salida estándar. debe "setearse" lo siguiente:
   447                                  ; ecx: el puntero al mensaje a desplegar
   448                                  ; edx: el largo del mensaje a desplegar
   449                                  ; modifica los registros eax y ebx.
   450                                  DisplayText:
   451 000002B3 B804000000                  mov     eax, sys_write
   452 000002B8 BB01000000                  mov     ebx, stdout
   453 000002BD CD80                        int     80h 
   454 000002BF C3                          ret
   455                                  
   456                                  ; lee algo de la entrada estándar.debe "setearse" lo siguiente:
   457                                  ; ecx: el puntero al buffer donde se almacenará
   458                                  ; edx: el largo del mensaje a leer
   459                                  ReadText:
   460 000002C0 BB00000000                  mov ebx, stdin
   461 000002C5 B803000000                  mov eax, sys_read
   462 000002CA CD80                        int 80H
   463 000002CC C3                          ret
   464                                  ;/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   
   465                                  ;http://stackoverflow.com/questions/19309749/nasm-assembly-convert-input-to-integer
   466                                  ;Input:
   467                                  ; EAX = integer value to convert
   468                                  ; ESI = pointer to buffer to store the string in (must have room for at least 10 bytes)
   469                                  ; Output:
   470                                  ; EAX = pointer to the first character of the generated string
   471                                  int_to_string:
   472 000002CD 56                      	push esi
   473 000002CE 83C609                  	add esi,9
   474 000002D1 C60600                  	mov byte [esi],0
   475 000002D4 BB0A000000              	mov ebx,10         
   476                                  .next_digit:
   477 000002D9 31D2                    	xor edx,edx         ; Clear edx prior to dividing edx:eax by ebx
   478 000002DB F7F3                    	div ebx             ; eax /= 10
   479 000002DD 80C230                  	add dl,'0'          ; Convert the remainder to ASCII 
   480 000002E0 4E                      	dec esi             ; store characters in reverse order
   481 000002E1 8816                    	mov [esi],dl
   482 000002E3 85C0                    	test eax,eax            
   483 000002E5 75F2                    	jnz .next_digit     ; Repeat until eax==0
   484 000002E7 89F0                    	mov eax,esi
   485 000002E9 5E                      	pop esi
   486 000002EA C3                      	ret
   487                                  ; Input:
   488                                  ; ESI = pointer to the string to convert
   489                                  ; ECX = number of digits in the string (must be > 0)
   490                                  ; Output:
   491                                  ; EAX = integer value
   492                                  string_to_int:
   493 000002EB 31DB                      xor ebx,ebx    ; clear ebx
   494                                  .next_digit:
   495 000002ED 0FB606                    movzx eax,byte[esi]
   496 000002F0 46                        inc esi
   497 000002F1 2C30                      sub al,'0'    ; convert from ASCII to number
   498 000002F3 6BDB0A                    imul ebx,10
   499 000002F6 01C3                      add ebx,eax   ; ebx = ebx*10 + eax
   500 000002F8 E2F3                      loop .next_digit  ; while (--ecx)
   501 000002FA 89D8                      mov eax,ebx
   502 000002FC C3                        ret
   503                                  ;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   504                                  ; La siguiente subrutina cierra el programa
   505                                  Cerrar:
   506 000002FD BA01000000              	mov edx,1
   507 00000302 B9[03000000]            	mov ecx, enter
   508 00000307 E8A7FFFFFF              	call DisplayText
   509 0000030C B801000000              	mov eax, sys_exit				;muevo la variabla sys_close al eax
   510 00000311 CD80                    	int 80h							;llamo a la interrupcion de kernel
